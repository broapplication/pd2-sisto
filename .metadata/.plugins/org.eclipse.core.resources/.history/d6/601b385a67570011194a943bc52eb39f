package it.polito.pd2.WF.sol6.service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import javax.jws.WebService;

import it.polito.pd2.WF.sol6.service.gen.ActionStatusType;
import it.polito.pd2.WF.sol6.service.gen.ActionsField;
import it.polito.pd2.WF.sol6.service.gen.ActorType;
import it.polito.pd2.WF.sol6.service.gen.GenericFault_Exception;
import it.polito.pd2.WF.sol6.service.gen.GetProcessSummaries.Fields;
import it.polito.pd2.WF.sol6.service.gen.GetProcessSummaries.Restrictions;
import it.polito.pd2.WF.sol6.service.gen.ProcessSummary;
import it.polito.pd2.WF.sol6.service.gen.UnknownCodes;
import it.polito.pd2.WF.sol6.service.gen.UnknownCodes_Exception;
import it.polito.pd2.WF.sol6.service.gen.UnknownNames;
import it.polito.pd2.WF.sol6.service.gen.UnknownNames_Exception;
import it.polito.pd2.WF.sol6.service.gen.UnknownRoles;
import it.polito.pd2.WF.sol6.service.gen.UnknownRoles_Exception;
import it.polito.pd2.WF.sol6.service.gen.WorkflowInfoPortType;
import it.polito.pd2.WF.sol6.service.gen.WorkflowType;

import it.polito.pd2.WF.sol6.service.WorkflowServer.Errors;
import it.polito.pd2.WF.sol6.service.WorkflowServer.Messages;

@WebService(
		name="WorkflowInfoPortType", 
		endpointInterface="it.polito.pd2.WF.sol6.service.gen.WorkflowInfoPortType", 
		wsdlLocation="META-INF/WorkflowService.wsdl",
		targetNamespace="http://pad.polito.it/Workflow", 
		serviceName="WorkflowInfoService", portName="WorkflowInfoPort")
public class WorkflowInfoServiceImpl implements WorkflowInfoPortType {
	
	private static final String REGEX_ID="^[a-zA-Z]\\w*";
	private static final String REGEX_ALPHA="^[a-zA-Z]$|^[a-zA-Z][a-zA-Z ]*[a-zA-Z]$";
	
	private WorkflowServer server;
	private static Logger logger = Logger.getLogger(WorkflowInfoServiceImpl.class.getName());
	
	public WorkflowInfoServiceImpl() {
		server=WorkflowServer.getInstance();
	}

	@Override
	public List<String> getWorkflowNames() throws GenericFault_Exception {
		try {
			return new ArrayList<String>(server.getWorkflows().keySet());
		} catch (WorkflowServerException e) {
			logger.warning(Messages.SERVER_NOT_READY);
			throw new GenericFault_Exception(
					Messages.SERVICE_UNAVAILABLE,
					Errors.SERVICE_UNAVAILABLE,
					e);
		}
	}

	@Override
	public List<WorkflowType> getWorkflows(List<String> name,
			String processField) throws GenericFault_Exception,
			UnknownNames_Exception {
		
		if((processField != null && !processField.equals("PCode") &&
				!processField.equals("processSummary")) || name == null) {
			logger.warning(Messages.REQUEST_NOT_WELL_FORMED);
			throw new GenericFault_Exception(
					Messages.REQUEST_NOT_WELL_FORMED,
					Errors.REQUEST_NOT_WELL_FORMED);
		}
		
		UnknownNames err=Errors.unknownNames();
		boolean error=false;
		
		Map<String, WorkflowType> workflows;
		try {
			workflows = server.getWorkflows();
		} catch (WorkflowServerException e) {
			logger.warning(Messages.SERVER_NOT_READY);
			throw new GenericFault_Exception(
					Messages.SERVICE_UNAVAILABLE,
					Errors.SERVICE_UNAVAILABLE,
					e);
		}
		
		List<WorkflowType> res=new ArrayList<WorkflowType>();
		for(String wfname : name) {			
			WorkflowType wf=workflows.get(wfname);
			if(wf==null) {
				//unknown name
				if(!error) 
					error=true;
				err.getNames().add(wfname);
			}
			if(error)	//just check for other unknown names
				continue;
			if(processField==null)	
				//processes not needed
				res.add(wf);
			else {
				//add processes
				WorkflowType workflow=new WorkflowType();
				workflow.setName(wf.getName());
				workflow.getAction().addAll(wf.getAction());
				
				List<ProcessSummary> processes;
				try {
					processes = server.getProcesses(wfname);
				} catch (WorkflowServerException e) {
					logger.warning(Messages.SERVER_NOT_READY);
					throw new GenericFault_Exception(
							Messages.SERVICE_UNAVAILABLE,
							Errors.SERVICE_UNAVAILABLE,
							e);
				}
				if(processField.equals("processSummary"))
					workflow.getProcessSummary().addAll(processes);
				else {
					List<String> codes=workflow.getPCode();
					for(ProcessSummary proc : processes)
						codes.add(proc.getPCode());
				}
				
				res.add(workflow);
			}
		}
		
		if(error)
			throw new UnknownNames_Exception(err.getMessage(), err);
		
		return res;
	}

	@Override
	public List<ProcessSummary> getProcessSummaries(Restrictions restrictions,
			Fields fields) throws GenericFault_Exception,
			UnknownCodes_Exception, UnknownNames_Exception,
			UnknownRoles_Exception {
		
		ProcessSummary process;
		HashSet<String> roles=null;
		HashSet<String> names=null;
		HashSet<String> codes=null;
		HashSet<ActorType> actors=null;
		List<ProcessSummary> res=new ArrayList<ProcessSummary>();
		UnknownNames errNames=Errors.unknownNames();
		UnknownCodes errCodes=Errors.unknownCodes();
		UnknownRoles errRoles=Errors.unknownRoles();
		
		try {
			
			//apply restrictions on processes
			if(restrictions != null) {
				
				//---------CHECK RESTRICTIONS---------------------
				//check and map roles (including actors' roles)
				List<String> checkRoles = restrictions.getRole();
				List<ActorType> checkActors = restrictions.getActor();
				HashSet<String> actorsRoles=null;
				if(!checkActors.isEmpty()) {
					actors=new HashSet<ActorType>(checkActors);
					actorsRoles=new HashSet<String>(); 
					for(ActorType actor : actors) {
						checkRoles.add(actor.getRole());
						actorsRoles.add(actor.getRole());
					}
				}
				if(!checkRoles.isEmpty()) {
					roles=splitList(checkRoles, server.getRoles());
					if(!checkRoles.isEmpty()) {
						//unknown roles
						errRoles=Errors.unknownRoles();
						errRoles.getRoles().addAll(checkRoles);
						throw new UnknownRoles_Exception(
								Messages.UNKNOWN_ROLES, 
								errRoles);
					} else if (actors != null)
						roles.retainAll(actorsRoles);
				}
				
				//check and map names
				List<String> checkNames=restrictions.getWorkflowName();
				if(!checkNames.isEmpty()) {
					names=splitList(checkNames, server.getWorkflows().keySet());
					if(!checkNames.isEmpty()) {
						//unknown names
						errNames=Errors.unknownNames();
						errNames.getNames().addAll(checkNames);
						throw new UnknownNames_Exception(
								Messages.UNKNOWN_NAMES,
								errNames);
					}
				}
				
				//check and map codes
				List<String> checkCodes=restrictions.getPCode();
				if(!checkCodes.isEmpty()) {
					codes=splitList(checkCodes, server.getProcesses().keySet());
					if(!checkCodes.isEmpty()) {
						//unknown Codes
						errCodes=Errors.unknownCodes();
						errCodes.getCodes().addAll(checkCodes);
						throw new UnknownCodes_Exception(
								Messages.UNKNOWN_CODES,
								errCodes);
					}
				}
			
				//---------FILTER PROCESSES---------------------
				//filter processes by code and workflow name
							
				if(codes != null) {
					//codes restrictions
					Map<String, ProcessSummary> processes=server.getProcesses();
					for(String PCode : codes) {
						process=processes.get(PCode);
						if(names == null || names.contains(process.getWorkflowName()))
							res.add(process);
					}
				} else if(names != null) {
					//names restrictions
					for(String name : names)
						res.addAll(server.getProcesses(name));
				} else {
					//no codes or names restrictions
					res.addAll(server.getProcesses().values());

				}

			}
			
			//------REBUILD PROCESSES--------------------
					
			List<ProcessSummary> newres = new ArrayList<ProcessSummary>();
			if(roles == null) {
				//rebuild processes selecting requested fields
				for(ProcessSummary proc : res) {
					process=duplicateProcessSummary(proc);
					modifyProcessSummaryFields(process, fields);
					//process rebuilt
					newres.add(process);
				}
			} else {
				//---------FILTER ACTIONS-----------------------------
				//rebuild processes filtering actions by actor and role
				for(ProcessSummary proc : res) {
					process=new ProcessSummary();
					//filter actions
					for(ActionStatusType status : proc.getActionStatus())
						if(roles.contains(status.getAction().getRole()) &&
								(actors == null || actors.contains(status.getActor())))
							process.getActionStatus().add(status);
					//check for remaining actions
					if(!process.getActionStatus().isEmpty()) {
						//don't skip process
						process.setPCode(proc.getPCode());
						process.setStartTime(proc.getStartTime());
						process.setWorkflowName(proc.getWorkflowName());
						for(ActionStatusType status : proc.getActiveActionStatus())
							if(roles.contains(status.getAction().getRole()) &&
									(actors == null || actors.contains(status.getActor())))
								process.getActiveActionStatus().add(status);
						for(ActionStatusType status : proc.getAvailableActionStatus())
							if(roles.contains(status.getAction().getRole()) &&
									(actors == null || actors.contains(status.getActor())))
								process.getAvailableActionStatus().add(status);
						for(ActionStatusType status : proc.getTerminatedActionStatus())
							if(roles.contains(status.getAction().getRole()) &&
									(actors == null || actors.contains(status.getActor())))
								process.getTerminatedActionStatus().add(status);
						
						modifyProcessSummaryFields(proc, fields);
						//process rebuilt
						newres.add(process);
					}
				}
			}
			
			res=newres;
				
		} catch (WorkflowServerException e) {
			logger.warning(Messages.SERVER_NOT_READY);
			throw new GenericFault_Exception(
					Messages.SERVICE_UNAVAILABLE,
					Errors.SERVICE_UNAVAILABLE,
					e);
		}
		return res;
	}
	
	private static ProcessSummary duplicateProcessSummary(ProcessSummary process) {
		ProcessSummary res=new ProcessSummary();
		res.setPCode(process.getPCode());
		res.setStartTime(process.getStartTime());
		res.setWorkflowName(process.getWorkflowName());
		res.getActionStatus().addAll(process.getActionStatus());
		res.getActiveActionStatus().addAll(process.getActiveActionStatus());
		res.getAvailableActionStatus().addAll(process.getAvailableActionStatus());
		res.getTerminatedActionStatus().addAll(process.getTerminatedActionStatus());
		return res;
	}
	
	private static void modifyProcessSummaryFields(ProcessSummary process, Fields fields) {
		//server stored processes have all fields and embedded actions
		
		//default fields
		boolean workflowName=false;
		boolean startTime=true;
		ActionsField actions=ActionsField.LIST;
		ActionsField availableActions=ActionsField.LENGTH;
		ActionsField activeActions=ActionsField.LENGTH;
		ActionsField terminatedActions=ActionsField.LENGTH;
		boolean actionFieldEmbedded=false;
		List<ActionStatusType> status;
		if(fields != null) {
			workflowName=fields.isWorkflowName();
			startTime=fields.isStartTime();
			actions=fields.getActions();
			availableActions=fields.getAvailableActions();
			activeActions=fields.getActiveActions();
			terminatedActions=fields.getTerminatedActions();
			if(fields.getActionFieldType().equals("action"))
				actionFieldEmbedded=true;
		}
		
		if(!workflowName)
			process.setWorkflowName(null);
		if(!startTime)
			process.setStartTime(null);
		
		status = process.getActionStatus();
		if(actions==ActionsField.LENGTH) {
			process.setActions(status.size());
			status.clear();
		} else if(!actionFieldEmbedded) {
			
		}
			
		if(availableActions==ActionsField.LENGTH) {
			process.setAvailableActions(process.getAvailableActionStatus().size());
			process.getAvailableActionStatus().clear();
		}
		if(activeActions==ActionsField.LENGTH) {
			process.setActiveActions(process.getActiveActionStatus().size());
			process.getActiveActionStatus().clear();
		}
		if(terminatedActions==ActionsField.LENGTH) {
			process.setTerminatedActions(process.getTerminatedActionStatus().size());
			process.getTerminatedActionStatus().clear();
		}
		
		
	}
	
	private static void detachActionFromStatus(List<ActionStatusType> list) {
		List<ActionStatusType> newList = new ArrayList<ActionStatusType>();
		ActionStatusType newStatus;
		for(ActionStatusType status : list) {
			newStatus=new ActionStatusType();
			newStatus.setACode(status.getACode());
			newStatus.setName(status.getAction().getName());
			newStatus.setActor(status.getActor());
			newStatus.setTerminationTime(status.getTerminationTime());
		}
	}
	
	private static <E> HashSet<E> splitList(Collection<E> toSplit, Collection<E> toCheckInto) {
		//commonPart = toSplit INTERSECT toCheckInto
		HashSet<E> commonPart=new HashSet<E>(toCheckInto);
		commonPart.retainAll(toSplit);
		//toSplit = toSplit MINUS commonPart
		toSplit.removeAll(commonPart);
		return commonPart;
	}

}
